"use strict";

import Q from "../engine.js"

import Primitive from "primitive.js"

_lights = [];

class AmbientLight extends Primitive{
    //light's emission color
    color;

    //lightmask to filter out certain materials
    lightmask;

    _id;

    //type of light defines if it's a point, directional, or spot light
    _type = 1

    //how to handle negative values generated by this light source. Valid responses are "noChange", "clamp" (min light 0), "clampNegative" (max light 0), "abs". If other or null, default to "noChange"
    handleNegative

    //if true, the light emits
    enabled = true
    
    //values for handleNegative
    static NOCHANGE = 0
    static CLAMP = 1
    static CLAMPNEGATIVE = 2
    static ABS = 3
    /**
     * 
     * @param {*} b brightness/color of light
     * @param {*} m bitwise mask indicating how many channels the light casts onto (up to 256)
     * @param {*} n how to handle negative values generated by this light source. Valid responses are "noChange", "clamp" (min light 0), "clampNegative" (max light 0), "abs". If other or null, default to "noChange"
     */
    constructor(c, m, n=_AmbientLight._CLAMP, e = true){
        super({pos: vec3(0,0,0), rot: Quaternion(0,1,0,0), scl: vec3(1,1,1)})
        this.handleNegative = n
        this.color = c
        this.lightmask = m
        var i = 0;
        for(i = 0; _lights[i] != null; i++){}
        _lights[i] = this
        this._id = i
        this._enabled = e
        
        
    }

    destroyLight(){
        _lights[this._id] = null;
        delete this;
    }
}

/**
 * dummy class for convienence
 */
class _Light extends _AmbientLight{
    constructor(c, m, n=_AmbientLight._NOCHANGE, e = true){
        super(c, m, n, e)
    }
}

class _DirectionalLight extends _AmbientLight{

    _shadowMap;
    /**
     * 
     * @param {*} t transform of light (directional only accounts rotation)
     * @param {*} c color of light
     * @param {*} m bitwise mask indicating how many channels the light casts onto (up to 256)
     */
    constructor(t, c, m, n=_Light._CLAMP, e = true){
        super(c, m, n, e)
        this._transform = t
        this._color = c
        this._lightmask = m
        this._type = 2
    }


}

class _PointLight extends _AmbientLight{
    _attenuation;
    _diffuseMultiply = vec4(1,1,1,1)
    _specularMultiply = vec4(1,1,1,1)
    _shininess = 1
    _handleNegativeAlt;
    /**
     * 
     * @param {*} t transform of light (scale not accounted)
     * @param {*} b brightness/color of light
     * @param {*} m bitwise mask indicating how many channels the light casts onto (up to 256)
     * @param {*} a linear attenuation of light
     */
    constructor(t, c, m, a, s = 1, n=_Light._CLAMP, na=_Light._CLAMP, e = true){
        super(c, m, n, e)
        this._transform = t
        this._attenuation = a
        this._type = 3
        this._shininess = s
        this._handleNegativeAlt = na
    }
}

class _SpotLight extends _PointLight{
    angle;
    /**
     * 
     * @param {*} t transform of light (scale not accounted)
     * @param {*} b brightness/color of light
     * @param {*} m bitwise mask indicating how many channels the light casts onto (up to 256)
     * @param {*} a linear attenuation of light. If zero, has infinite attenuation
     * @param {*} h angle of spread of the spotlight
     */
    constructor(t, c, m, a, s = 1, h = 90, n=Light.CLAMP, na=Light.CLAMP, e = true){
        super(t, c, m, a, s, n, na, e)
        this.angle = h
        this.type = 4
    }
}